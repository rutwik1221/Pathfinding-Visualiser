{"ast":null,"code":"export function astar(grid, start, end) {\n  console.log(\"Start:\" + start.col);\n  console.log(\"END:\" + end.isWall);\n\n  if (!start || !end || start === end) {\n    return false;\n  }\n\n  let openSet = new Set();\n  openSet.add(start);\n  let cameFrom = new Map();\n  let gScore = new Map();\n  gScore.set(start, 0);\n  let fscore = new Map();\n  fscore.set(start, manhattanDistance(start, end));\n\n  while (openSet.size > 0) {\n    let current = min(fscore);\n\n    if (current === end) {\n      return shortestPath(end);\n    }\n\n    openSet.delete(current);\n    let neighbours = getNeighbours(grid, current);\n\n    for (let node of neighbours) {\n      let tentative_gScore = gScore.get(current) + 1;\n\n      if (tentative_gScore < gScore.get(node)) {\n        cameFrom.set(node, current);\n        gScore.set(node, tentative_gScore);\n        fscore.set(node, gScore.get(node) + manhattanDistance(node, end));\n\n        if (!openSet.has(node)) {\n          openSet.add(node);\n        }\n      }\n    }\n  }\n}\n\nfunction min(fscore) {\n  let minKey,\n      minVal = 99999;\n\n  for (let [key, value] of fscore) {\n    if (value < minVal) {\n      minVal = value;\n      minKey = key;\n    }\n  }\n\n  return minKey;\n}\n\nfunction getNeighbours(grid, current) {\n  let neighbours = [];\n\n  if (current.row === 0) {\n    if (current.col === 0) {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n    } else if (current.col === 49) {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    } else {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    }\n  } else if (current.row === 19) {\n    if (current.col === 0) {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n    } else if (current.col === 49) {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    } else {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    }\n  } else if (current.col === 0) {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col + 1]);\n  } else if (current.col === 49) {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col - 1]);\n  } else {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col + 1]);\n    neighbours.push(grid[current.row][current.col - 1]);\n  }\n\n  return neighbours.filter(n => !n.isWall);\n}\n\nfunction closestNode(grid, unvisitedNodes) {\n  let currentClosest, index;\n\n  for (let i = 0; i < unvisitedNodes.length; i++) {\n    if (!currentClosest || currentClosest.totalDistance > grid[unvisitedNodes[i]].totalDistance) {\n      currentClosest = grid[unvisitedNodes[i]];\n      index = i;\n    } else if (currentClosest.totalDistance === grid[unvisitedNodes[i]].totalDistance) {\n      if (currentClosest.heuristicDistance > grid[unvisitedNodes[i]].heuristicDistance) {\n        currentClosest = grid[unvisitedNodes[i]];\n        index = i;\n      }\n    }\n  }\n\n  unvisitedNodes.splice(index, 1);\n  return currentClosest;\n}\n\nfunction updateNeighbors(grid, node, boardArray, target, name, start, heuristic) {\n  let neighbors = getNeighbors(node.id, grid, boardArray);\n\n  for (let neighbor of neighbors) {\n    if (target) {\n      updateNode(node, grid[neighbor], grid[target], name, grid, grid[start], heuristic, boardArray);\n    } else {\n      updateNode(node, grid[neighbor]);\n    }\n  }\n}\n\nfunction updateNode(currentNode, targetNode, actualTargetNode, name, grid, actualStartNode, heuristic, boardArray) {\n  let distance = getDistance(currentNode, targetNode);\n  if (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\n  let distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n\n  if (distanceToCompare < targetNode.distance) {\n    targetNode.distance = distanceToCompare;\n    targetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\n    targetNode.previousNode = currentNode.id;\n    targetNode.path = distance[1];\n    targetNode.direction = distance[2];\n  }\n}\n\nfunction getNeighbors(id, grid, boardArray) {\n  let coordinates = id.split(\"-\");\n  let x = parseInt(coordinates[0]);\n  let y = parseInt(coordinates[1]);\n  let neighbors = [];\n  let potentialNeighbor;\n\n  if (boardArray[x - 1] && boardArray[x - 1][y]) {\n    potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`;\n    if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x + 1] && boardArray[x + 1][y]) {\n    potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`;\n    if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x][y - 1]) {\n    potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`;\n    if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x][y + 1]) {\n    potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`;\n    if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  return neighbors;\n}\n\nfunction getDistance(nodeOne, nodeTwo) {\n  let currentCoordinates = nodeOne.id.split(\"-\");\n  let targetCoordinates = nodeTwo.id.split(\"-\");\n  let x1 = parseInt(currentCoordinates[0]);\n  let y1 = parseInt(currentCoordinates[1]);\n  let x2 = parseInt(targetCoordinates[0]);\n  let y2 = parseInt(targetCoordinates[1]);\n\n  if (x2 < x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [1, [\"f\"], \"up\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"l\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"up\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"up\"];\n    }\n  } else if (x2 > x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"l\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [1, [\"f\"], \"down\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"down\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"down\"];\n    }\n  }\n\n  if (y2 < y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [1, [\"f\"], \"left\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"r\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"left\"];\n    }\n  } else if (y2 > y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [1, [\"f\"], \"right\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"l\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"right\"];\n    }\n  }\n}\n\nfunction manhattanDistance(n1, n2) {\n  let x = Math.abs(n2.row - n1.row);\n  let y = Math.abs(n2.col - n2.col);\n  return x + y;\n}\n\nfunction shortestPath(node) {\n  const path = [];\n\n  while (node !== null) {\n    path.puah(node);\n    node = node.previousNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/astar.js"],"names":["astar","grid","start","end","console","log","col","isWall","openSet","Set","add","cameFrom","Map","gScore","set","fscore","manhattanDistance","size","current","min","shortestPath","delete","neighbours","getNeighbours","node","tentative_gScore","get","has","minKey","minVal","key","value","row","push","filter","n","closestNode","unvisitedNodes","currentClosest","index","i","length","totalDistance","heuristicDistance","splice","updateNeighbors","boardArray","target","name","heuristic","neighbors","getNeighbors","id","neighbor","updateNode","currentNode","targetNode","actualTargetNode","actualStartNode","distance","getDistance","distanceToCompare","weight","previousNode","path","direction","coordinates","split","x","parseInt","y","potentialNeighbor","toString","status","nodeOne","nodeTwo","currentCoordinates","targetCoordinates","x1","y1","x2","y2","n1","n2","Math","abs","puah"],"mappings":"AAAA,OAAO,SAASA,KAAT,CAAeC,IAAf,EAAqBC,KAArB,EAA4BC,GAA5B,EAAiC;AACvCC,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAWH,KAAK,CAACI,GAA7B;AACAF,EAAAA,OAAO,CAACC,GAAR,CAAY,SAASF,GAAG,CAACI,MAAzB;;AACG,MAAI,CAACL,KAAD,IAAU,CAACC,GAAX,IAAkBD,KAAK,KAAKC,GAAhC,EAAqC;AACpC,WAAO,KAAP;AACA;;AACJ,MAAIK,OAAO,GAAE,IAAIC,GAAJ,EAAb;AACAD,EAAAA,OAAO,CAACE,GAAR,CAAYR,KAAZ;AACG,MAAIS,QAAQ,GAAG,IAAIC,GAAJ,EAAf;AACH,MAAIC,MAAM,GAAG,IAAID,GAAJ,EAAb;AACAC,EAAAA,MAAM,CAACC,GAAP,CAAWZ,KAAX,EAAiB,CAAjB;AACA,MAAIa,MAAM,GAAG,IAAIH,GAAJ,EAAb;AACAG,EAAAA,MAAM,CAACD,GAAP,CAAWZ,KAAX,EAAiBc,iBAAiB,CAACd,KAAD,EAAOC,GAAP,CAAlC;;AACG,SAAMK,OAAO,CAACS,IAAR,GAAa,CAAnB,EAAqB;AACpB,QAAIC,OAAO,GAAGC,GAAG,CAACJ,MAAD,CAAjB;;AACA,QAAGG,OAAO,KAAGf,GAAb,EAAiB;AACb,aAAOiB,YAAY,CAACjB,GAAD,CAAnB;AACH;;AACDK,IAAAA,OAAO,CAACa,MAAR,CAAeH,OAAf;AACH,QAAII,UAAU,GAAGC,aAAa,CAACtB,IAAD,EAAMiB,OAAN,CAA9B;;AACA,SAAI,IAAIM,IAAR,IAAgBF,UAAhB,EAA2B;AAC1B,UAAIG,gBAAgB,GAAGZ,MAAM,CAACa,GAAP,CAAWR,OAAX,IAAsB,CAA7C;;AACA,UAAGO,gBAAgB,GAACZ,MAAM,CAACa,GAAP,CAAWF,IAAX,CAApB,EAAqC;AACpCb,QAAAA,QAAQ,CAACG,GAAT,CAAaU,IAAb,EAAkBN,OAAlB;AACAL,QAAAA,MAAM,CAACC,GAAP,CAAWU,IAAX,EAAgBC,gBAAhB;AACAV,QAAAA,MAAM,CAACD,GAAP,CAAWU,IAAX,EAAgBX,MAAM,CAACa,GAAP,CAAWF,IAAX,IAAiBR,iBAAiB,CAACQ,IAAD,EAAMrB,GAAN,CAAlD;;AACA,YAAG,CAACK,OAAO,CAACmB,GAAR,CAAYH,IAAZ,CAAJ,EAAsB;AACrBhB,UAAAA,OAAO,CAACE,GAAR,CAAYc,IAAZ;AACA;AACD;AACD;AACE;AACJ;;AACD,SAASL,GAAT,CAAaJ,MAAb,EAAoB;AACnB,MAAIa,MAAJ;AAAA,MAAYC,MAAM,GAAC,KAAnB;;AACA,OAAI,IAAI,CAACC,GAAD,EAAKC,KAAL,CAAR,IAAuBhB,MAAvB,EAA8B;AAC1B,QAAGgB,KAAK,GAACF,MAAT,EAAgB;AACZA,MAAAA,MAAM,GAACE,KAAP;AACAH,MAAAA,MAAM,GAACE,GAAP;AACH;AACJ;;AACE,SAAOF,MAAP;AACH;;AACD,SAASL,aAAT,CAAuBtB,IAAvB,EAA4BiB,OAA5B,EAAoC;AACnC,MAAII,UAAU,GAAC,EAAf;;AACA,MAAGJ,OAAO,CAACc,GAAR,KAAc,CAAjB,EAAmB;AAClB,QAAGd,OAAO,CAACZ,GAAR,KAAc,CAAjB,EAAmB;AAClBgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,KAHD,MAIK,IAAGY,OAAO,CAACZ,GAAR,KAAc,EAAjB,EAAoB;AACxBgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,KAHI,MAID;AACHgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA;AACD,GAdD,MAeK,IAAGY,OAAO,CAACc,GAAR,KAAc,EAAjB,EAAoB;AACxB,QAAGd,OAAO,CAACZ,GAAR,KAAc,CAAjB,EAAmB;AAClBgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,KAHD,MAIK,IAAGY,OAAO,CAACZ,GAAR,KAAc,EAAjB,EAAoB;AACxBgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,KAHI,MAID;AACHgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACAgB,MAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA;AACD,GAdI,MAeA,IAAGY,OAAO,CAACZ,GAAR,KAAc,CAAjB,EAAmB;AACvBgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,GAJI,MAKA,IAAGY,OAAO,CAACZ,GAAR,KAAc,EAAjB,EAAoB;AACxBgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA,GAJI,MAKD;AACHgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAR,GAAY,CAAb,CAAJ,CAAoBd,OAAO,CAACZ,GAA5B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACAgB,IAAAA,UAAU,CAACW,IAAX,CAAgBhC,IAAI,CAACiB,OAAO,CAACc,GAAT,CAAJ,CAAkBd,OAAO,CAACZ,GAAR,GAAY,CAA9B,CAAhB;AACA;;AACD,SAAOgB,UAAU,CAACY,MAAX,CAAkBC,CAAC,IAAI,CAACA,CAAC,CAAC5B,MAA1B,CAAP;AACA;;AACC,SAAS6B,WAAT,CAAqBnC,IAArB,EAA2BoC,cAA3B,EAA2C;AACzC,MAAIC,cAAJ,EAAoBC,KAApB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,cAAc,CAACI,MAAnC,EAA2CD,CAAC,EAA5C,EAAgD;AAC9C,QAAI,CAACF,cAAD,IAAmBA,cAAc,CAACI,aAAf,GAA+BzC,IAAI,CAACoC,cAAc,CAACG,CAAD,CAAf,CAAJ,CAAwBE,aAA9E,EAA6F;AAC3FJ,MAAAA,cAAc,GAAGrC,IAAI,CAACoC,cAAc,CAACG,CAAD,CAAf,CAArB;AACAD,MAAAA,KAAK,GAAGC,CAAR;AACD,KAHD,MAGO,IAAIF,cAAc,CAACI,aAAf,KAAiCzC,IAAI,CAACoC,cAAc,CAACG,CAAD,CAAf,CAAJ,CAAwBE,aAA7D,EAA4E;AACjF,UAAIJ,cAAc,CAACK,iBAAf,GAAmC1C,IAAI,CAACoC,cAAc,CAACG,CAAD,CAAf,CAAJ,CAAwBG,iBAA/D,EAAkF;AAChFL,QAAAA,cAAc,GAAGrC,IAAI,CAACoC,cAAc,CAACG,CAAD,CAAf,CAArB;AACAD,QAAAA,KAAK,GAAGC,CAAR;AACD;AACF;AACF;;AACDH,EAAAA,cAAc,CAACO,MAAf,CAAsBL,KAAtB,EAA6B,CAA7B;AACA,SAAOD,cAAP;AACD;;AAED,SAASO,eAAT,CAAyB5C,IAAzB,EAA+BuB,IAA/B,EAAqCsB,UAArC,EAAiDC,MAAjD,EAAyDC,IAAzD,EAA+D9C,KAA/D,EAAsE+C,SAAtE,EAAiF;AAC/E,MAAIC,SAAS,GAAGC,YAAY,CAAC3B,IAAI,CAAC4B,EAAN,EAAUnD,IAAV,EAAgB6C,UAAhB,CAA5B;;AACA,OAAK,IAAIO,QAAT,IAAqBH,SAArB,EAAgC;AAC9B,QAAIH,MAAJ,EAAY;AACVO,MAAAA,UAAU,CAAC9B,IAAD,EAAOvB,IAAI,CAACoD,QAAD,CAAX,EAAuBpD,IAAI,CAAC8C,MAAD,CAA3B,EAAqCC,IAArC,EAA2C/C,IAA3C,EAAiDA,IAAI,CAACC,KAAD,CAArD,EAA8D+C,SAA9D,EAAyEH,UAAzE,CAAV;AACD,KAFD,MAEO;AACLQ,MAAAA,UAAU,CAAC9B,IAAD,EAAOvB,IAAI,CAACoD,QAAD,CAAX,CAAV;AACD;AACF;AACF;;AAED,SAASC,UAAT,CAAoBC,WAApB,EAAiCC,UAAjC,EAA6CC,gBAA7C,EAA+DT,IAA/D,EAAqE/C,IAArE,EAA2EyD,eAA3E,EAA4FT,SAA5F,EAAuGH,UAAvG,EAAmH;AACjH,MAAIa,QAAQ,GAAGC,WAAW,CAACL,WAAD,EAAcC,UAAd,CAA1B;AACA,MAAI,CAACA,UAAU,CAACb,iBAAhB,EAAmCa,UAAU,CAACb,iBAAX,GAA+B3B,iBAAiB,CAACwC,UAAD,EAAaC,gBAAb,CAAhD;AACnC,MAAII,iBAAiB,GAAGN,WAAW,CAACI,QAAZ,GAAuBH,UAAU,CAACM,MAAlC,GAA2CH,QAAQ,CAAC,CAAD,CAA3E;;AACA,MAAIE,iBAAiB,GAAGL,UAAU,CAACG,QAAnC,EAA6C;AAC3CH,IAAAA,UAAU,CAACG,QAAX,GAAsBE,iBAAtB;AACAL,IAAAA,UAAU,CAACd,aAAX,GAA2Bc,UAAU,CAACG,QAAX,GAAsBH,UAAU,CAACb,iBAA5D;AACAa,IAAAA,UAAU,CAACO,YAAX,GAA0BR,WAAW,CAACH,EAAtC;AACAI,IAAAA,UAAU,CAACQ,IAAX,GAAkBL,QAAQ,CAAC,CAAD,CAA1B;AACAH,IAAAA,UAAU,CAACS,SAAX,GAAuBN,QAAQ,CAAC,CAAD,CAA/B;AACD;AACF;;AAED,SAASR,YAAT,CAAsBC,EAAtB,EAA0BnD,IAA1B,EAAgC6C,UAAhC,EAA4C;AAC1C,MAAIoB,WAAW,GAAGd,EAAE,CAACe,KAAH,CAAS,GAAT,CAAlB;AACA,MAAIC,CAAC,GAAGC,QAAQ,CAACH,WAAW,CAAC,CAAD,CAAZ,CAAhB;AACA,MAAII,CAAC,GAAGD,QAAQ,CAACH,WAAW,CAAC,CAAD,CAAZ,CAAhB;AACA,MAAIhB,SAAS,GAAG,EAAhB;AACA,MAAIqB,iBAAJ;;AACA,MAAIzB,UAAU,CAACsB,CAAC,GAAG,CAAL,CAAV,IAAqBtB,UAAU,CAACsB,CAAC,GAAG,CAAL,CAAV,CAAkBE,CAAlB,CAAzB,EAA+C;AAC7CC,IAAAA,iBAAiB,GAAI,GAAE,CAACH,CAAC,GAAG,CAAL,EAAQI,QAAR,EAAmB,IAAGF,CAAC,CAACE,QAAF,EAAa,EAA1D;AACA,QAAIvE,IAAI,CAACsE,iBAAD,CAAJ,CAAwBE,MAAxB,KAAmC,MAAvC,EAA+CvB,SAAS,CAACjB,IAAV,CAAesC,iBAAf;AAChD;;AACD,MAAIzB,UAAU,CAACsB,CAAC,GAAG,CAAL,CAAV,IAAqBtB,UAAU,CAACsB,CAAC,GAAG,CAAL,CAAV,CAAkBE,CAAlB,CAAzB,EAA+C;AAC7CC,IAAAA,iBAAiB,GAAI,GAAE,CAACH,CAAC,GAAG,CAAL,EAAQI,QAAR,EAAmB,IAAGF,CAAC,CAACE,QAAF,EAAa,EAA1D;AACA,QAAIvE,IAAI,CAACsE,iBAAD,CAAJ,CAAwBE,MAAxB,KAAmC,MAAvC,EAA+CvB,SAAS,CAACjB,IAAV,CAAesC,iBAAf;AAChD;;AACD,MAAIzB,UAAU,CAACsB,CAAD,CAAV,CAAcE,CAAC,GAAG,CAAlB,CAAJ,EAA0B;AACxBC,IAAAA,iBAAiB,GAAI,GAAEH,CAAC,CAACI,QAAF,EAAa,IAAG,CAACF,CAAC,GAAG,CAAL,EAAQE,QAAR,EAAmB,EAA1D;AACA,QAAIvE,IAAI,CAACsE,iBAAD,CAAJ,CAAwBE,MAAxB,KAAmC,MAAvC,EAA+CvB,SAAS,CAACjB,IAAV,CAAesC,iBAAf;AAChD;;AACD,MAAIzB,UAAU,CAACsB,CAAD,CAAV,CAAcE,CAAC,GAAG,CAAlB,CAAJ,EAA0B;AACxBC,IAAAA,iBAAiB,GAAI,GAAEH,CAAC,CAACI,QAAF,EAAa,IAAG,CAACF,CAAC,GAAG,CAAL,EAAQE,QAAR,EAAmB,EAA1D;AACA,QAAIvE,IAAI,CAACsE,iBAAD,CAAJ,CAAwBE,MAAxB,KAAmC,MAAvC,EAA+CvB,SAAS,CAACjB,IAAV,CAAesC,iBAAf;AAChD;;AACD,SAAOrB,SAAP;AACD;;AAGD,SAASU,WAAT,CAAqBc,OAArB,EAA8BC,OAA9B,EAAuC;AACrC,MAAIC,kBAAkB,GAAGF,OAAO,CAACtB,EAAR,CAAWe,KAAX,CAAiB,GAAjB,CAAzB;AACA,MAAIU,iBAAiB,GAAGF,OAAO,CAACvB,EAAR,CAAWe,KAAX,CAAiB,GAAjB,CAAxB;AACA,MAAIW,EAAE,GAAGT,QAAQ,CAACO,kBAAkB,CAAC,CAAD,CAAnB,CAAjB;AACA,MAAIG,EAAE,GAAGV,QAAQ,CAACO,kBAAkB,CAAC,CAAD,CAAnB,CAAjB;AACA,MAAII,EAAE,GAAGX,QAAQ,CAACQ,iBAAiB,CAAC,CAAD,CAAlB,CAAjB;AACA,MAAII,EAAE,GAAGZ,QAAQ,CAACQ,iBAAiB,CAAC,CAAD,CAAlB,CAAjB;;AACA,MAAIG,EAAE,GAAGF,EAAL,IAAWC,EAAE,KAAKE,EAAtB,EAA0B;AACxB,QAAIP,OAAO,CAACT,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,CAAJ,EAAW,IAAX,CAAP;AACD,KAFD,MAEO,IAAIS,OAAO,CAACT,SAAR,KAAsB,OAA1B,EAAmC;AACxC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,IAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,IAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAJ,EAAqB,IAArB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,UAA1B,EAAsC;AAC3C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,YAA1B,EAAwC;AAC7C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,SAA1B,EAAqC;AAC1C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,WAA1B,EAAuC;AAC5C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAP;AACD;AACF,GAlBD,MAkBO,IAAIe,EAAE,GAAGF,EAAL,IAAWC,EAAE,KAAKE,EAAtB,EAA0B;AAC/B,QAAIP,OAAO,CAACT,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAJ,EAAqB,MAArB,CAAP;AACD,KAFD,MAEO,IAAIS,OAAO,CAACT,SAAR,KAAsB,OAA1B,EAAmC;AACxC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,MAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,MAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,CAAJ,EAAW,MAAX,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,UAA1B,EAAsC;AAC3C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,YAA1B,EAAwC;AAC7C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,SAA1B,EAAqC;AAC1C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,WAA1B,EAAuC;AAC5C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD;AACF;;AACD,MAAIgB,EAAE,GAAGF,EAAL,IAAWD,EAAE,KAAKE,EAAtB,EAA0B;AACxB,QAAIN,OAAO,CAACT,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,MAAhB,CAAP;AACD,KAFD,MAEO,IAAIS,OAAO,CAACT,SAAR,KAAsB,OAA1B,EAAmC;AACxC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAJ,EAAqB,MAArB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,CAAJ,EAAW,MAAX,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,MAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,UAA1B,EAAsC;AAC3C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,YAA1B,EAAwC;AAC7C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,SAA1B,EAAqC;AAC1C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,WAA1B,EAAuC;AAC5C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,MAAZ,CAAP;AACD;AACF,GAlBD,MAkBO,IAAIgB,EAAE,GAAGF,EAAL,IAAWD,EAAE,KAAKE,EAAtB,EAA0B;AAC/B,QAAIN,OAAO,CAACT,SAAR,KAAsB,IAA1B,EAAgC;AAC9B,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,OAAhB,CAAP;AACD,KAFD,MAEO,IAAIS,OAAO,CAACT,SAAR,KAAsB,OAA1B,EAAmC;AACxC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,CAAJ,EAAW,OAAX,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAJ,EAAqB,OAArB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,MAA1B,EAAkC;AACvC,aAAO,CAAC,CAAD,EAAI,CAAC,GAAD,EAAM,GAAN,CAAJ,EAAgB,OAAhB,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,UAA1B,EAAsC;AAC3C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,OAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,YAA1B,EAAwC;AAC7C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,OAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,SAA1B,EAAqC;AAC1C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,OAAZ,CAAP;AACD,KAFM,MAEA,IAAIS,OAAO,CAACT,SAAR,KAAsB,WAA1B,EAAuC;AAC5C,aAAO,CAAC,GAAD,EAAM,IAAN,EAAY,OAAZ,CAAP;AACD;AACF;AACF;;AAEH,SAASjD,iBAAT,CAA2BkE,EAA3B,EAA+BC,EAA/B,EAAmC;AAClC,MAAIf,CAAC,GAACgB,IAAI,CAACC,GAAL,CAASF,EAAE,CAACnD,GAAH,GAAOkD,EAAE,CAAClD,GAAnB,CAAN;AACA,MAAIsC,CAAC,GAACc,IAAI,CAACC,GAAL,CAASF,EAAE,CAAC7E,GAAH,GAAO6E,EAAE,CAAC7E,GAAnB,CAAN;AACA,SAAQ8D,CAAC,GAACE,CAAV;AACA;;AACD,SAASlD,YAAT,CAAsBI,IAAtB,EAA2B;AACvB,QAAMwC,IAAI,GAAG,EAAb;;AACA,SAAMxC,IAAI,KAAG,IAAb,EAAkB;AACdwC,IAAAA,IAAI,CAACsB,IAAL,CAAU9D,IAAV;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAACuC,YAAZ;AACH;;AACD,SAAOC,IAAP;AACH","sourcesContent":["export function astar(grid, start, end) {\r\n\tconsole.log(\"Start:\" + start.col);\r\n\tconsole.log(\"END:\" + end.isWall);\r\n    if (!start || !end || start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n}\r\n  function closestNode(grid, unvisitedNodes) {\r\n    let currentClosest, index;\r\n    for (let i = 0; i < unvisitedNodes.length; i++) {\r\n      if (!currentClosest || currentClosest.totalDistance > grid[unvisitedNodes[i]].totalDistance) {\r\n        currentClosest = grid[unvisitedNodes[i]];\r\n        index = i;\r\n      } else if (currentClosest.totalDistance === grid[unvisitedNodes[i]].totalDistance) {\r\n        if (currentClosest.heuristicDistance > grid[unvisitedNodes[i]].heuristicDistance) {\r\n          currentClosest = grid[unvisitedNodes[i]];\r\n          index = i;\r\n        }\r\n      }\r\n    }\r\n    unvisitedNodes.splice(index, 1);\r\n    return currentClosest;\r\n  }\r\n  \r\n  function updateNeighbors(grid, node, boardArray, target, name, start, heuristic) {\r\n    let neighbors = getNeighbors(node.id, grid, boardArray);\r\n    for (let neighbor of neighbors) {\r\n      if (target) {\r\n        updateNode(node, grid[neighbor], grid[target], name, grid, grid[start], heuristic, boardArray);\r\n      } else {\r\n        updateNode(node, grid[neighbor]);\r\n      }\r\n    }\r\n  }\r\n  \r\n  function updateNode(currentNode, targetNode, actualTargetNode, name, grid, actualStartNode, heuristic, boardArray) {\r\n    let distance = getDistance(currentNode, targetNode);\r\n    if (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\r\n    let distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\r\n    if (distanceToCompare < targetNode.distance) {\r\n      targetNode.distance = distanceToCompare;\r\n      targetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\r\n      targetNode.previousNode = currentNode.id;\r\n      targetNode.path = distance[1];\r\n      targetNode.direction = distance[2];\r\n    }\r\n  }\r\n  \r\n  function getNeighbors(id, grid, boardArray) {\r\n    let coordinates = id.split(\"-\");\r\n    let x = parseInt(coordinates[0]);\r\n    let y = parseInt(coordinates[1]);\r\n    let neighbors = [];\r\n    let potentialNeighbor;\r\n    if (boardArray[x - 1] && boardArray[x - 1][y]) {\r\n      potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`\r\n      if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n    }\r\n    if (boardArray[x + 1] && boardArray[x + 1][y]) {\r\n      potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`\r\n      if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n    }\r\n    if (boardArray[x][y - 1]) {\r\n      potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`\r\n      if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n    }\r\n    if (boardArray[x][y + 1]) {\r\n      potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`\r\n      if (grid[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n    }\r\n    return neighbors;\r\n  }\r\n  \r\n  \r\n  function getDistance(nodeOne, nodeTwo) {\r\n    let currentCoordinates = nodeOne.id.split(\"-\");\r\n    let targetCoordinates = nodeTwo.id.split(\"-\");\r\n    let x1 = parseInt(currentCoordinates[0]);\r\n    let y1 = parseInt(currentCoordinates[1]);\r\n    let x2 = parseInt(targetCoordinates[0]);\r\n    let y2 = parseInt(targetCoordinates[1]);\r\n    if (x2 < x1 && y1 === y2) {\r\n      if (nodeOne.direction === \"up\") {\r\n        return [1, [\"f\"], \"up\"];\r\n      } else if (nodeOne.direction === \"right\") {\r\n        return [2, [\"l\", \"f\"], \"up\"];\r\n      } else if (nodeOne.direction === \"left\") {\r\n        return [2, [\"r\", \"f\"], \"up\"];\r\n      } else if (nodeOne.direction === \"down\") {\r\n        return [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n      } else if (nodeOne.direction === \"up-right\") {\r\n        return [1.5, null, \"up\"];\r\n      } else if (nodeOne.direction === \"down-right\") {\r\n        return [2.5, null, \"up\"];\r\n      } else if (nodeOne.direction === \"up-left\") {\r\n        return [1.5, null, \"up\"];\r\n      } else if (nodeOne.direction === \"down-left\") {\r\n        return [2.5, null, \"up\"];\r\n      }\r\n    } else if (x2 > x1 && y1 === y2) {\r\n      if (nodeOne.direction === \"up\") {\r\n        return [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n      } else if (nodeOne.direction === \"right\") {\r\n        return [2, [\"r\", \"f\"], \"down\"];\r\n      } else if (nodeOne.direction === \"left\") {\r\n        return [2, [\"l\", \"f\"], \"down\"];\r\n      } else if (nodeOne.direction === \"down\") {\r\n        return [1, [\"f\"], \"down\"];\r\n      } else if (nodeOne.direction === \"up-right\") {\r\n        return [2.5, null, \"down\"];\r\n      } else if (nodeOne.direction === \"down-right\") {\r\n        return [1.5, null, \"down\"];\r\n      } else if (nodeOne.direction === \"up-left\") {\r\n        return [2.5, null, \"down\"];\r\n      } else if (nodeOne.direction === \"down-left\") {\r\n        return [1.5, null, \"down\"];\r\n      }\r\n    }\r\n    if (y2 < y1 && x1 === x2) {\r\n      if (nodeOne.direction === \"up\") {\r\n        return [2, [\"l\", \"f\"], \"left\"];\r\n      } else if (nodeOne.direction === \"right\") {\r\n        return [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n      } else if (nodeOne.direction === \"left\") {\r\n        return [1, [\"f\"], \"left\"];\r\n      } else if (nodeOne.direction === \"down\") {\r\n        return [2, [\"r\", \"f\"], \"left\"];\r\n      } else if (nodeOne.direction === \"up-right\") {\r\n        return [2.5, null, \"left\"];\r\n      } else if (nodeOne.direction === \"down-right\") {\r\n        return [2.5, null, \"left\"];\r\n      } else if (nodeOne.direction === \"up-left\") {\r\n        return [1.5, null, \"left\"];\r\n      } else if (nodeOne.direction === \"down-left\") {\r\n        return [1.5, null, \"left\"];\r\n      }\r\n    } else if (y2 > y1 && x1 === x2) {\r\n      if (nodeOne.direction === \"up\") {\r\n        return [2, [\"r\", \"f\"], \"right\"];\r\n      } else if (nodeOne.direction === \"right\") {\r\n        return [1, [\"f\"], \"right\"];\r\n      } else if (nodeOne.direction === \"left\") {\r\n        return [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n      } else if (nodeOne.direction === \"down\") {\r\n        return [2, [\"l\", \"f\"], \"right\"];\r\n      } else if (nodeOne.direction === \"up-right\") {\r\n        return [1.5, null, \"right\"];\r\n      } else if (nodeOne.direction === \"down-right\") {\r\n        return [1.5, null, \"right\"];\r\n      } else if (nodeOne.direction === \"up-left\") {\r\n        return [2.5, null, \"right\"];\r\n      } else if (nodeOne.direction === \"down-left\") {\r\n        return [2.5, null, \"right\"];\r\n      }\r\n    } \r\n  }\r\n  \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}"]},"metadata":{},"sourceType":"module"}