{"ast":null,"code":"export function astar(grid, start, end) {\n  if (start === end) {\n    return false;\n  }\n\n  let openSet = new Set();\n  openSet.add(start);\n  let cameFrom = new Map();\n  let gScore = new Map();\n  gScore.set(start, 0);\n  let fscore = new Map();\n  fscore.set(start, manhattanDistance(start, end));\n  console.log(openSet);\n  console.log(fscore);\n  console.log(gScore);\n\n  while (openSet.size > 0) {\n    let current = min(fscore);\n\n    if (current === end) {\n      return shortestPath(end);\n    }\n\n    openSet.delete(current);\n    let neighbours = getNeighbours(grid, current);\n\n    for (let node of neighbours) {\n      let tentative_gScore = gScore.get(current) + 1;\n\n      if (tentative_gScore < gScore.get(node)) {\n        cameFrom.set(node, current);\n        gScore.set(node, tentative_gScore);\n        fscore.set(node, gScore.get(node) + manhattanDistance(node, end));\n\n        if (!openSet.has(node)) {\n          openSet.add(node);\n        }\n      }\n    }\n  }\n}\n\nfunction min(fscore) {\n  let minKey,\n      minVal = 99999;\n\n  for (let [key, value] of fscore) {\n    if (value < minVal) {\n      minVal = value;\n      minKey = key;\n    }\n  }\n\n  return minKey;\n}\n\nfunction getNeighbours(grid, current) {\n  let neighbours = [];\n\n  if (current.row === 0) {\n    if (current.col === 0) {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n    } else if (current.col === 49) {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    } else {\n      neighbours.push(grid[current.row + 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    }\n  } else if (current.row === 19) {\n    if (current.col === 0) {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n    } else if (current.col === 49) {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    } else {\n      neighbours.push(grid[current.row - 1][current.col]);\n      neighbours.push(grid[current.row][current.col + 1]);\n      neighbours.push(grid[current.row][current.col - 1]);\n    }\n  } else if (current.col === 0) {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col + 1]);\n  } else if (current.col === 49) {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col - 1]);\n  } else {\n    neighbours.push(grid[current.row + 1][current.col]);\n    neighbours.push(grid[current.row - 1][current.col]);\n    neighbours.push(grid[current.row][current.col + 1]);\n    neighbours.push(grid[current.row][current.col - 1]);\n  }\n\n  return neighbours.filter(n => !n.isWall);\n}\n\nfunction manhattanDistance(n1, n2) {\n  let x = Math.abs(n2.row - n1.row);\n  let y = Math.abs(n2.col - n2.col);\n  return x + y;\n}\n\nfunction shortestPath(node) {\n  const path = [];\n\n  while (node !== null) {\n    path.puah(node);\n    node = node.previousNode;\n  }\n\n  return path;\n}\n/*\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !end || start === end) {\r\n\t\treturn false;\r\n\t}\r\n\tlet visitedNodesInOrder = [];\r\n\tstart.distance = 0;\r\n\tstart.totalDistance = 0;\r\n\tstart.direction = \"up\";\r\n\tlet unvisitedNodes=getNodes(grid);\r\n\twhile (unvisitedNodes.length) {\r\n\t\tconsole.log(unvisitedNodes)\r\n\t\tlet currentNode = closestNode(unvisitedNodes)\r\n\t\tconsole.log(currentNode)\r\n\t\tif (currentNode.distance === Infinity) \r\n\t\t  \treturn false;\r\n\t\tvisitedNodesInOrder.push(currentNode);\r\n\t  \tcurrentNode.isVisited=true;;\r\n\t  \tif (currentNode === end) {\r\n\t\t\treturn visitedNodesInOrder;\r\n\t  \t}\r\n\t  \tupdateNeighbors(grid, currentNode, end, start);\r\n\t}\r\n}\r\nfunction getNodes(grid){\r\n\tlet nodes = [];\r\n\t\tfor(const row of grid){\r\n\t\t\tfor(const node of row){\r\n\t\t\t\tif(!node.isWall){\r\n\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t}\r\n\t\t \t}\r\n\t \t}\r\n\treturn nodes;\r\n}\r\n\r\nfunction closestNode(unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\tindex = i;\r\n\t\t} \r\n\t  \telse if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n\t\t  \tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n\t\t  \t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t  \t\tindex = i;\r\n\t\t\t}\r\n\t  \t}\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n\t}\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, start, end) {\r\n\tlet neighbours = getNeighbours(currentNode,grid);\r\n\tfor (let neighbour of neighbours) {\r\n\t\tif (end) {\r\n\t\t\tupdateNode(currentNode, neighbour, end, start );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdateNode(currentNode, neighbour);\r\n\t  \t}\r\n\t}\r\n}\r\n\r\n  \r\nfunction updateNode(currentNode, neighbour, end) {\r\n\tlet distance = getDistance(currentNode, neighbour);\r\n\tif (!neighbour.heuristicDistance) \r\n\t\tneighbour.heuristicDistance = manhattanDistance(neighbour, end);\r\n\tlet distanceToCompare = currentNode.distance + distance[0];\r\n\tif (distanceToCompare < neighbour.distance) {\r\n\t\tneighbour.distance = distanceToCompare;\r\n\t\tneighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\r\n\t\tneighbour.previousNode = currentNode;\r\n\t\tneighbour.path = distance[1];\r\n\t\tneighbour.direction = distance[2];\r\n\t}\r\n}\r\n\r\n   \r\nfunction getDistance(n1, n2) {\r\n\tlet x1=n1.row;\r\n\tlet x2=n2.row;\r\n\tlet y1=n1.col;\r\n\tlet y2=n2.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}*/","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/astar.js"],"names":["astar","grid","start","end","openSet","Set","add","cameFrom","Map","gScore","set","fscore","manhattanDistance","console","log","size","current","min","shortestPath","delete","neighbours","getNeighbours","node","tentative_gScore","get","has","minKey","minVal","key","value","row","col","push","filter","n","isWall","n1","n2","x","Math","abs","y","path","puah","previousNode"],"mappings":"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","sourcesContent":["export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n\tconsole.log(openSet);\r\n\tconsole.log(fscore);\r\n\tconsole.log(gScore);\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n} \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}\r\n/*\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !end || start === end) {\r\n\t\treturn false;\r\n\t}\r\n\tlet visitedNodesInOrder = [];\r\n\tstart.distance = 0;\r\n\tstart.totalDistance = 0;\r\n\tstart.direction = \"up\";\r\n\tlet unvisitedNodes=getNodes(grid);\r\n\twhile (unvisitedNodes.length) {\r\n\t\tconsole.log(unvisitedNodes)\r\n\t\tlet currentNode = closestNode(unvisitedNodes)\r\n\t\tconsole.log(currentNode)\r\n\t\tif (currentNode.distance === Infinity) \r\n\t\t  \treturn false;\r\n\t\tvisitedNodesInOrder.push(currentNode);\r\n\t  \tcurrentNode.isVisited=true;;\r\n\t  \tif (currentNode === end) {\r\n\t\t\treturn visitedNodesInOrder;\r\n\t  \t}\r\n\t  \tupdateNeighbors(grid, currentNode, end, start);\r\n\t}\r\n}\r\nfunction getNodes(grid){\r\n\tlet nodes = [];\r\n\t\tfor(const row of grid){\r\n\t\t\tfor(const node of row){\r\n\t\t\t\tif(!node.isWall){\r\n\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t}\r\n\t\t \t}\r\n\t \t}\r\n\treturn nodes;\r\n}\r\n\r\nfunction closestNode(unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\tindex = i;\r\n\t\t} \r\n\t  \telse if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n\t\t  \tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n\t\t  \t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t  \t\tindex = i;\r\n\t\t\t}\r\n\t  \t}\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n\t}\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, start, end) {\r\n\tlet neighbours = getNeighbours(currentNode,grid);\r\n\tfor (let neighbour of neighbours) {\r\n\t\tif (end) {\r\n\t\t\tupdateNode(currentNode, neighbour, end, start );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdateNode(currentNode, neighbour);\r\n\t  \t}\r\n\t}\r\n}\r\n\r\n  \r\nfunction updateNode(currentNode, neighbour, end) {\r\n\tlet distance = getDistance(currentNode, neighbour);\r\n\tif (!neighbour.heuristicDistance) \r\n\t\tneighbour.heuristicDistance = manhattanDistance(neighbour, end);\r\n\tlet distanceToCompare = currentNode.distance + distance[0];\r\n\tif (distanceToCompare < neighbour.distance) {\r\n\t\tneighbour.distance = distanceToCompare;\r\n\t\tneighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\r\n\t\tneighbour.previousNode = currentNode;\r\n\t\tneighbour.path = distance[1];\r\n\t\tneighbour.direction = distance[2];\r\n\t}\r\n}\r\n\r\n   \r\nfunction getDistance(n1, n2) {\r\n\tlet x1=n1.row;\r\n\tlet x2=n2.row;\r\n\tlet y1=n1.col;\r\n\tlet y2=n2.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}*/  "]},"metadata":{},"sourceType":"module"}