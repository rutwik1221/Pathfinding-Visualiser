{"ast":null,"code":"export function BreadthFirstSearch(grid, startNode, endNode) {\n  let visitedNodesInOrder = [];\n  let unvisitedNodes = [];\n  startNode.isVisited = true;\n  unvisitedNodes.push(startNode);\n  let prevNode = startNode;\n  let currentNode = unvisitedNodes.shift();\n\n  while (unvisitedNodes.length > 0) {\n    prevNode = currentNode;\n    currentNode.previousNode = prevNode;\n    currentNode = unvisitedNodes.shift();\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === endNode) {\n      return {\n        visitedOrder: visitedNodesInOrder,\n        path: Path(endNode)\n      };\n    }\n\n    currentNode.isVisited = true;\n    unvisitedNodes.push(...getUnvisitedNeighbours(currentNode, grid));\n  }\n}\nexport function DepthFirstSearch(grid, startNode, endNode) {\n  let visitedNodesInOrder = [];\n  let unvisitedNodes = [];\n  startNode.isVisited = true;\n  unvisitedNodes.unshift(startNode);\n  let prevNode = startNode;\n  let currentNode = unvisitedNodes.shift();\n\n  while (unvisitedNodes.length > 0) {\n    prevNode = currentNode;\n    currentNode.previousNode = prevNode;\n    currentNode = unvisitedNodes.shift();\n    visitedNodesInOrder.push(currentNode);\n\n    if (currentNode === endNode) {\n      return {\n        visitedOrder: visitedNodesInOrder,\n        path: Path(endNode)\n      };\n    }\n\n    currentNode.isVisited = true;\n    unvisitedNodes.unshift(...getUnvisitedNeighbours(currentNode, grid));\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbours.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    neighbours.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    neighbours.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbours.push(grid[row][col + 1]);\n  }\n\n  return neighbours.filter(neighbour => !neighbour.isVisited && !neighbour.isWall);\n}\n\nexport function Path(endNode) {\n  const path = [];\n\n  while (endNode !== null) {\n    path.unshift(endNode);\n    endNode = endNode.previousNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/BreadthFirstSearch.js"],"names":["BreadthFirstSearch","grid","startNode","endNode","visitedNodesInOrder","unvisitedNodes","isVisited","push","prevNode","currentNode","shift","length","previousNode","visitedOrder","path","Path","getUnvisitedNeighbours","DepthFirstSearch","unshift","node","neighbours","col","row","filter","neighbour","isWall"],"mappings":"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","sourcesContent":["export function BreadthFirstSearch(grid,startNode,endNode){\r\n    let visitedNodesInOrder = [];\r\n    let unvisitedNodes=[];\r\n    startNode.isVisited=true;\r\n    unvisitedNodes.push(startNode);\r\n    let prevNode=startNode;\r\n    let currentNode = unvisitedNodes.shift();\r\n    while(unvisitedNodes.length>0){\r\n        prevNode=currentNode;\r\n        currentNode.previousNode=prevNode;\r\n        currentNode = unvisitedNodes.shift();\r\n        visitedNodesInOrder.push(currentNode);\r\n        if(currentNode===endNode){\r\n            return {\r\n\t\t\t\tvisitedOrder:visitedNodesInOrder,\r\n\t\t\t\tpath:Path(endNode),\r\n\t\t\t};\r\n        }\r\n        currentNode.isVisited=true;\r\n        unvisitedNodes.push(...getUnvisitedNeighbours(currentNode,grid));     \r\n    }\r\n}\r\nexport function DepthFirstSearch(grid,startNode,endNode){\r\n    let visitedNodesInOrder = [];\r\n    let unvisitedNodes=[];\r\n    startNode.isVisited=true;\r\n    unvisitedNodes.unshift(startNode);\r\n    let prevNode=startNode;\r\n    let currentNode = unvisitedNodes.shift();\r\n    while(unvisitedNodes.length>0){\r\n        prevNode=currentNode;\r\n        currentNode.previousNode=prevNode;\r\n        currentNode = unvisitedNodes.shift();\r\n        visitedNodesInOrder.push(currentNode);\r\n        if(currentNode===endNode){\r\n            return {\r\n\t\t\t\tvisitedOrder:visitedNodesInOrder,\r\n\t\t\t\tpath:Path(endNode),\r\n\t\t\t};\r\n        }\r\n        currentNode.isVisited=true;\r\n        unvisitedNodes.unshift(...getUnvisitedNeighbours(currentNode,grid));     \r\n    }\r\n}\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isVisited&&!neighbour.isWall);\r\n}\r\nexport function Path(endNode){\r\n    const path = [];\r\n    while(endNode!==null){\r\n        path.unshift(endNode);\r\n        endNode = endNode.previousNode;\r\n    }\r\n    return path;\r\n}"]},"metadata":{},"sourceType":"module"}