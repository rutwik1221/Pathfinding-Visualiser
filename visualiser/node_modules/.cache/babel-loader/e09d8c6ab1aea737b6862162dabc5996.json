{"ast":null,"code":"export function dijkstra(grid, startNode, endNode) {\n  let visitedNodesInOrder = [];\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n\n  while (unvisitedNodes.length > 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    const closestNode = unvisitedNodes.shift();\n\n    if (closestNode.distance === Infinity) {\n      return visitedNodesInOrder;\n    }\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === endNode) {\n      return visitedNodesInOrder;\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbours.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    neighbours.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    neighbours.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbours.push(grid[row][col + 1]);\n  }\n\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n\n  for (const row in grid) {\n    for (const node in row) {\n      if (!col.isWall) {\n        nodes.push(col);\n      }\n    }\n  }\n\n  console.log(\"here\");\n  console.log(nodes);\n  console.log(grid[0][0]);\n}\n\nexport function shortestPath(endNode) {\n  const path = [];\n\n  while (endNode !== null) {\n    path.unshift(endNode);\n    endNode = endNode.previousNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","getNodes","length","sort","a","b","closestNode","shift","Infinity","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","previousNode","neighbours","col","row","filter","nodes","isWall","console","log","shortestPath","path","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid,startNode,endNode){\r\n    let visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    let unvisitedNodes=getNodes(grid);\r\n    while(unvisitedNodes.length>0){\r\n        unvisitedNodes.sort((a,b) => a.distance - b.distance);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.distance=== Infinity){\r\n            return visitedNodesInOrder;\r\n        }\r\n        closestNode.isVisited=true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode===endNode){\r\n            return visitedNodesInOrder;\r\n        }\r\n        updateUnvisitedNeighbours(closestNode,grid);\r\n    }\r\n}\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n    for (const neighbour of unvisitedNeighbours) {\r\n      neighbour.distance = node.distance + 1;\r\n      neighbour.previousNode = node;\r\n    }\r\n}\r\n  \r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nfunction getNodes(grid){\r\n   let nodes = [];\r\n    for(const row in grid){\r\n        for(const node in row){\r\n            if(!col.isWall){\r\n                nodes.push(col);\r\n            }\r\n        }\r\n    }\r\n    console.log(\"here\");\r\n    console.log(nodes);\r\n    console.log(grid[0][0]);\r\n}\r\n\r\nexport function shortestPath(endNode){\r\n    const path = [];\r\n    while(endNode!==null){\r\n        path.unshift(endNode);\r\n        endNode = endNode.previousNode;\r\n    }\r\n    return path;\r\n}"]},"metadata":{},"sourceType":"module"}