{"ast":null,"code":"export function dijkstra(grid, startNode, endNode) {\n  let visitedNodesInOrder = [];\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n\n  while (unvisitedNodes.length > 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    const closestNode = unvisitedNodes.shift();\n\n    if (closestNode.distance === Infinity) {\n      return {\n        visitedOrder: visitedNodesInOrder,\n        path: shortestPath(endNode)\n      };\n    }\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    if (closestNode === endNode) {\n      return {\n        visitedOrder: visitedNodesInOrder,\n        path: shortestPath(endNode)\n      };\n    }\n\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbour of unvisitedNeighbours) {\n    neighbour.distance = node.distance + 1;\n    neighbour.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbours.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    neighbours.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    neighbours.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbours.push(grid[row][col + 1]);\n  }\n\n  return neighbours.filter(neighbour => !neighbour.isVisited);\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      if (!node.isWall) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return nodes;\n}\n\nexport function shortestPath(endNode) {\n  const path = [];\n\n  while (endNode !== null) {\n    path.unshift(endNode);\n    endNode = endNode.previousNode;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","getNodes","length","sort","a","b","closestNode","shift","Infinity","visitedOrder","path","shortestPath","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","previousNode","neighbours","col","row","filter","nodes","isWall","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid,startNode,endNode){\r\n    let visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    let unvisitedNodes=getNodes(grid);\r\n    while(unvisitedNodes.length>0){\r\n        unvisitedNodes.sort((a,b) => a.distance - b.distance);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if(closestNode.distance=== Infinity){\r\n            return {\r\n\t\t\t\tvisitedOrder:visitedNodesInOrder,\r\n\t\t\t\tpath:shortestPath(endNode),\r\n\t\t\t};\r\n        }\r\n        closestNode.isVisited=true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if(closestNode===endNode){\r\n            return {\r\n\t\t\t\tvisitedOrder:visitedNodesInOrder,\r\n\t\t\t\tpath:shortestPath(endNode),\r\n\t\t\t};\r\n        }\r\n        updateUnvisitedNeighbours(closestNode,grid);\r\n    }\r\n}\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n    for (const neighbour of unvisitedNeighbours) {\r\n      neighbour.distance = node.distance + 1;\r\n      neighbour.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isVisited);\r\n}\r\n\r\nfunction getNodes(grid){\r\n   let nodes = [];\r\n    for(const row of grid){\r\n        for(const node of row){\r\n            if(!node.isWall){\r\n                nodes.push(node);\r\n            }\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function shortestPath(endNode){\r\n    const path = [];\r\n    while(endNode!==null){\r\n        path.unshift(endNode);\r\n        endNode = endNode.previousNode;\r\n    }\r\n    return path;\r\n}"]},"metadata":{},"sourceType":"module"}