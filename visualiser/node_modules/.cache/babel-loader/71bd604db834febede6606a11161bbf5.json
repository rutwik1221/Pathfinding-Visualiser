{"ast":null,"code":"export function astar(grid, start, end) {\n  if (start === end) {\n    return false;\n  }\n\n  let visitOrder = [];\n  let openSet = new Set();\n  openSet.add(start);\n  let closedSet = new Set();\n  let gCost = new Map();\n  let hCost = new Map();\n  let fCost = new Map();\n  let prev = new Map();\n  gCost.set(start, setgCost(start, start));\n  hCost.set(start, sethCost(start, end));\n  fCost.set(start, gCost.get(start) + hCost.get(start));\n\n  while (openSet.size > 0) {\n    let current = min(fCost, hCost);\n    console.log(current.row + \"-\" + current.col + \"\\tfcost:\" + fCost.get(current) + \"\\tgcost:\" + gCost.get(current) + \"\\thcost:\" + hCost.get(current));\n    visitOrder.push(current);\n    openSet.delete(current);\n    gCost.delete(current);\n    hCost.delete(current);\n    fCost.delete(current);\n    closedSet.add(current);\n\n    if (current === end) {\n      return {\n        visitedOrder: visitOrder,\n        path: path(end)\n      };\n    }\n\n    let neighbours = getNeighbours(current, grid);\n\n    for (let node of neighbours) {\n      if (!closedSet.has(node)) {\n        if (!openSet.has(node)) {\n          gCost.set(node, setgCost(node, start));\n          hCost.set(node, sethCost(node, end));\n          fCost.set(node, gCost.get(node) + hCost.get(node));\n          prev.set(node, current);\n\n          if (!openSet.has(node)) {\n            openSet.add(node);\n          }\n        }\n      }\n    }\n  } //console.log(fCost);\n  //console.log(gCost);\n  //console.log(hCost);\n\n\n  function path(node) {\n    let path = [];\n\n    while (prev.has(node)) {\n      path.push(node);\n      node = prev.get(node);\n    }\n\n    return path;\n  }\n\n  return {\n    visitOrder: visitOrder,\n    path: path(end)\n  };\n}\n\nfunction setgCost(node, start) {\n  return manhattanDistance(node, start);\n}\n\nfunction sethCost(node, end) {\n  return manhattanDistance(node, end);\n}\n\nfunction min(fCost, hCost) {\n  let minKey,\n      minVal = Infinity;\n  let d = [];\n\n  for (let [key, value] of fCost) {\n    if (value < minVal) {\n      minVal = value;\n      minKey = key;\n    }\n  }\n\n  for (let [key, value] of fCost) {\n    if (value === minVal) {\n      d.push(key);\n    }\n  }\n\n  minVal = Infinity;\n\n  for (let i = 0; i < d.length; d++) {\n    if (hCost.get(d[i]) < minVal) {\n      minKey = d[i];\n      minVal = hCost.get(d[i]);\n    }\n  }\n\n  return minKey;\n}\n\nfunction getNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbours.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    neighbours.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    neighbours.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbours.push(grid[row][col + 1]);\n  }\n\n  return neighbours.filter(neighbour => !neighbour.isWall);\n}\n\nfunction manhattanDistance(n1, n2) {\n  let x = Math.abs(n2.row - n1.row);\n  let y = Math.abs(n2.col - n2.col);\n  return x + y;\n}\n/*\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !end || start === end) {\r\n\t\treturn false;\r\n\t}\r\n\tlet visitedNodesInOrder = [];\r\n\tstart.distance = 0;\r\n\tstart.totalDistance = 0;\r\n\tstart.direction = \"up\";\r\n\tlet unvisitedNodes=getNodes(grid);\r\n\twhile (unvisitedNodes.length) {\r\n\t\tconsole.log(unvisitedNodes)\r\n\t\tlet currentNode = closestNode(unvisitedNodes)\r\n\t\tconsole.log(currentNode)\r\n\t\tif (currentNode.distance === Infinity) \r\n\t\t  \treturn false;\r\n\t\tvisitedNodesInOrder.push(currentNode);\r\n\t  \tcurrentNode.isVisited=true;;\r\n\t  \tif (currentNode === end) {\r\n\t\t\treturn visitedNodesInOrder;\r\n\t  \t}\r\n\t  \tupdateNeighbors(grid, currentNode, end, start);\r\n\t}\r\n}\r\nfunction getNodes(grid){\r\n\tlet nodes = [];\r\n\t\tfor(const row of grid){\r\n\t\t\tfor(const node of row){\r\n\t\t\t\tif(!node.isWall){\r\n\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t}\r\n\t\t \t}\r\n\t \t}\r\n\treturn nodes;\r\n}\r\n\r\nfunction closestNode(unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\tindex = i;\r\n\t\t} \r\n\t  \telse if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n\t\t  \tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n\t\t  \t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t  \t\tindex = i;\r\n\t\t\t}\r\n\t  \t}\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n\t}\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, start, end) {\r\n\tlet neighbours = getNeighbours(currentNode,grid);\r\n\tfor (let neighbour of neighbours) {\r\n\t\tif (end) {\r\n\t\t\tupdateNode(currentNode, neighbour, end, start );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdateNode(currentNode, neighbour);\r\n\t  \t}\r\n\t}\r\n}\r\n\r\n  \r\nfunction updateNode(currentNode, neighbour, end) {\r\n\tlet distance = getDistance(currentNode, neighbour);\r\n\tif (!neighbour.heuristicDistance) \r\n\t\tneighbour.heuristicDistance = manhattanDistance(neighbour, end);\r\n\tlet distanceToCompare = currentNode.distance + distance[0];\r\n\tif (distanceToCompare < neighbour.distance) {\r\n\t\tneighbour.distance = distanceToCompare;\r\n\t\tneighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\r\n\t\tneighbour.previousNode = currentNode;\r\n\t\tneighbour.path = distance[1];\r\n\t\tneighbour.direction = distance[2];\r\n\t}\r\n}\r\n\r\n   \r\nfunction getDistance(n1, n2) {\r\n\tlet x1=n1.row;\r\n\tlet x2=n2.row;\r\n\tlet y1=n1.col;\r\n\tlet y2=n2.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}*/","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/astar.js"],"names":["astar","grid","start","end","visitOrder","openSet","Set","add","closedSet","gCost","Map","hCost","fCost","prev","set","setgCost","sethCost","get","size","current","min","console","log","row","col","push","delete","visitedOrder","path","neighbours","getNeighbours","node","has","manhattanDistance","minKey","minVal","Infinity","d","key","value","i","length","filter","neighbour","isWall","n1","n2","x","Math","abs","y"],"mappings":"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","sourcesContent":["export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n\t}\r\n\tlet visitOrder=[];\r\n\tlet openSet= new Set();\r\n\t\topenSet.add(start);\r\n\tlet closedSet = new Set();\r\n\tlet gCost = new Map();\r\n\tlet hCost = new Map();\r\n\tlet fCost = new Map();\r\n\tlet prev = new Map();\r\n\tgCost.set(start,setgCost(start,start));\r\n\thCost.set(start,sethCost(start,end));\r\n\tfCost.set(start,gCost.get(start) + hCost.get(start));\r\n\r\n\twhile(openSet.size>0){\r\n\t\tlet current = min(fCost,hCost);\r\n\t\tconsole.log(current.row +\"-\"+ current.col +\"\\tfcost:\"+ fCost.get(current)+ \"\\tgcost:\"+ gCost.get(current)+\"\\thcost:\"+ hCost.get(current));\r\n\t\tvisitOrder.push(current);\r\n\t\topenSet.delete(current);\r\n\t\tgCost.delete(current);\r\n\t\thCost.delete(current);\r\n\t\tfCost.delete(current);\r\n\t\tclosedSet.add(current);\r\n    \tif(current===end){\r\n        \treturn {\r\n\t\t\t\tvisitedOrder:visitOrder,\r\n\t\t\t\tpath:path(end),\r\n\t\t\t};\r\n    \t}\r\n\t\tlet neighbours = getNeighbours(current,grid);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tif(!closedSet.has(node)){\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\tgCost.set(node,setgCost(node,start));\r\n\t\t\t\t\thCost.set(node,sethCost(node,end));\r\n\t\t\t\t\tfCost.set(node, gCost.get(node) + hCost.get(node) );\r\n\t\t\t\t\tprev.set(node,current);\r\n\t\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//console.log(fCost);\r\n\t//console.log(gCost);\r\n\t//console.log(hCost);\r\n\tfunction path(node){\r\n\t\tlet path=[];\r\n\t\twhile(prev.has(node)){\r\n\t\t\tpath.push(node);\r\n\t\t\tnode=prev.get(node);\r\n\t\t}\r\n\t\treturn path;\r\n\t}\r\n\treturn {\r\n\t\tvisitOrder:visitOrder,\r\n\t\tpath:path(end),\r\n\t};\r\n}\r\n\r\nfunction setgCost(node,start){\r\n\treturn manhattanDistance(node,start)\r\n}\r\nfunction sethCost(node,end){\r\n\treturn manhattanDistance(node,end)\r\n}\r\nfunction min(fCost,hCost){\r\n\tlet minKey, minVal=Infinity;\r\n\tlet d = [];\r\n\tfor(let [key,value] of fCost){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n\t\t}\r\n\t}\r\n\tfor(let [key,value] of fCost){\r\n    \tif(value===minVal){\r\n        \td.push(key);\r\n\t\t}\r\n\t}\r\n\tminVal=Infinity;\r\n\tfor(let i=0;i<d.length;d++){\r\n\t\tif(hCost.get(d[i])<minVal){\r\n\t\t\tminKey=d[i];\r\n\t\t\tminVal=hCost.get(d[i]);\r\n\t\t}\r\n\t}\r\n    return minKey;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n\t}\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\n/*\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !end || start === end) {\r\n\t\treturn false;\r\n\t}\r\n\tlet visitedNodesInOrder = [];\r\n\tstart.distance = 0;\r\n\tstart.totalDistance = 0;\r\n\tstart.direction = \"up\";\r\n\tlet unvisitedNodes=getNodes(grid);\r\n\twhile (unvisitedNodes.length) {\r\n\t\tconsole.log(unvisitedNodes)\r\n\t\tlet currentNode = closestNode(unvisitedNodes)\r\n\t\tconsole.log(currentNode)\r\n\t\tif (currentNode.distance === Infinity) \r\n\t\t  \treturn false;\r\n\t\tvisitedNodesInOrder.push(currentNode);\r\n\t  \tcurrentNode.isVisited=true;;\r\n\t  \tif (currentNode === end) {\r\n\t\t\treturn visitedNodesInOrder;\r\n\t  \t}\r\n\t  \tupdateNeighbors(grid, currentNode, end, start);\r\n\t}\r\n}\r\nfunction getNodes(grid){\r\n\tlet nodes = [];\r\n\t\tfor(const row of grid){\r\n\t\t\tfor(const node of row){\r\n\t\t\t\tif(!node.isWall){\r\n\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t}\r\n\t\t \t}\r\n\t \t}\r\n\treturn nodes;\r\n}\r\n\r\nfunction closestNode(unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\tindex = i;\r\n\t\t} \r\n\t  \telse if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n\t\t  \tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n\t\t  \t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t  \t\tindex = i;\r\n\t\t\t}\r\n\t  \t}\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n\t}\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, start, end) {\r\n\tlet neighbours = getNeighbours(currentNode,grid);\r\n\tfor (let neighbour of neighbours) {\r\n\t\tif (end) {\r\n\t\t\tupdateNode(currentNode, neighbour, end, start );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdateNode(currentNode, neighbour);\r\n\t  \t}\r\n\t}\r\n}\r\n\r\n  \r\nfunction updateNode(currentNode, neighbour, end) {\r\n\tlet distance = getDistance(currentNode, neighbour);\r\n\tif (!neighbour.heuristicDistance) \r\n\t\tneighbour.heuristicDistance = manhattanDistance(neighbour, end);\r\n\tlet distanceToCompare = currentNode.distance + distance[0];\r\n\tif (distanceToCompare < neighbour.distance) {\r\n\t\tneighbour.distance = distanceToCompare;\r\n\t\tneighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\r\n\t\tneighbour.previousNode = currentNode;\r\n\t\tneighbour.path = distance[1];\r\n\t\tneighbour.direction = distance[2];\r\n\t}\r\n}\r\n\r\n   \r\nfunction getDistance(n1, n2) {\r\n\tlet x1=n1.row;\r\n\tlet x2=n2.row;\r\n\tlet y1=n1.col;\r\n\tlet y2=n2.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}*/  "]},"metadata":{},"sourceType":"module"}