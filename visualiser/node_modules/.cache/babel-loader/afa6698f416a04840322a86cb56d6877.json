{"ast":null,"code":"/*export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n\tconsole.log(openSet);\r\n\tconsole.log(fscore);\r\n\tconsole.log(gScore);\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n} \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}*/\nexport function astar(grid, start, end) {\n  if (!start || !end || start === end) {\n    return false;\n  }\n\n  let visitedNodesInOrder = [];\n  start.distance = 0;\n  start.totalDistance = 0;\n  start.direction = \"up\";\n  let unvisitedNodes = getNodes(grid);\n\n  while (unvisitedNodes.length) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let currentNode = unvisitedNodes.shift();\n    if (currentNode.distance === Infinity) return false;\n    visitedNodesInOrder.push(currentNode);\n    currentNode.isVisited = true;\n    ;\n\n    if (currentNode === end) {\n      return visitedNodesInOrder;\n    }\n\n    updateNeighbors(grid, currentNode, end, start);\n  }\n}\n\nfunction getNodes(grid) {\n  let nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      if (!node.isWall) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction closestNode(nodes, unvisitedNodes) {\n  let currentClosest, index;\n\n  for (let i = 0; i < unvisitedNodes.length; i++) {\n    if (!currentClosest || currentClosest.totalDistance > nodes[unvisitedNodes[i]].totalDistance) {\n      currentClosest = nodes[unvisitedNodes[i]];\n      index = i;\n    } else if (currentClosest.totalDistance === nodes[unvisitedNodes[i]].totalDistance) {\n      if (currentClosest.heuristicDistance > nodes[unvisitedNodes[i]].heuristicDistance) {\n        currentClosest = nodes[unvisitedNodes[i]];\n        index = i;\n      }\n    }\n  }\n\n  unvisitedNodes.splice(index, 1);\n  return currentClosest;\n}\n\nfunction getNeighbours(node, grid) {\n  const neighbours = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbours.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    neighbours.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    neighbours.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbours.push(grid[row][col + 1]);\n  }\n\n  return neighbours.filter(neighbour => !neighbour.isWall);\n}\n\nfunction updateNeighbors(grid, currentNode, start, end) {\n  let neighbours = getNeighbours(currentNode, grid);\n\n  for (let neighbour of neighbours) {\n    if (end) {\n      updateNode(currentNode, neighbour, end, start);\n    } else {\n      updateNode(currentNode, neighbour);\n    }\n  }\n}\n\nfunction updateNode(currentNode, neighbour, end) {\n  let distance = getDistance(currentNode, neighbour);\n  if (!neighbour.heuristicDistance) neighbour.heuristicDistance = manhattanDistance(neighbour, end);\n  let distanceToCompare = currentNode.distance + distance[0];\n\n  if (distanceToCompare < neighbour.distance) {\n    neighbour.distance = distanceToCompare;\n    neighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\n    neighbour.previousNode = currentNode;\n    neighbour.path = distance[1];\n    neighbour.direction = distance[2];\n  }\n}\n\nfunction getDistance(n1, n2) {\n  let x1 = n1.row;\n  let x2 = n2.row;\n  let y1 = n1.col;\n  let y2 = n2.col;\n\n  if (x2 < x1 && y1 === y2) {\n    if (n1.direction === \"up\") {\n      return [1, [\"f\"], \"up\"];\n    } else if (n1.direction === \"right\") {\n      return [2, [\"l\", \"f\"], \"up\"];\n    } else if (n1.direction === \"left\") {\n      return [2, [\"r\", \"f\"], \"up\"];\n    } else if (n1.direction === \"down\") {\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\n    } else if (n1.direction === \"up-right\") {\n      return [1.5, null, \"up\"];\n    } else if (n1.direction === \"down-right\") {\n      return [2.5, null, \"up\"];\n    } else if (n1.direction === \"up-left\") {\n      return [1.5, null, \"up\"];\n    } else if (n1.direction === \"down-left\") {\n      return [2.5, null, \"up\"];\n    }\n  } else if (x2 > x1 && y1 === y2) {\n    if (n1.direction === \"up\") {\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\n    } else if (n1.direction === \"right\") {\n      return [2, [\"r\", \"f\"], \"down\"];\n    } else if (n1.direction === \"left\") {\n      return [2, [\"l\", \"f\"], \"down\"];\n    } else if (n1.direction === \"down\") {\n      return [1, [\"f\"], \"down\"];\n    } else if (n1.direction === \"up-right\") {\n      return [2.5, null, \"down\"];\n    } else if (n1.direction === \"down-right\") {\n      return [1.5, null, \"down\"];\n    } else if (n1.direction === \"up-left\") {\n      return [2.5, null, \"down\"];\n    } else if (n1.direction === \"down-left\") {\n      return [1.5, null, \"down\"];\n    }\n  }\n\n  if (y2 < y1 && x1 === x2) {\n    if (n1.direction === \"up\") {\n      return [2, [\"l\", \"f\"], \"left\"];\n    } else if (n1.direction === \"right\") {\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\n    } else if (n1.direction === \"left\") {\n      return [1, [\"f\"], \"left\"];\n    } else if (n1.direction === \"down\") {\n      return [2, [\"r\", \"f\"], \"left\"];\n    } else if (n1.direction === \"up-right\") {\n      return [2.5, null, \"left\"];\n    } else if (n1.direction === \"down-right\") {\n      return [2.5, null, \"left\"];\n    } else if (n1.direction === \"up-left\") {\n      return [1.5, null, \"left\"];\n    } else if (n1.direction === \"down-left\") {\n      return [1.5, null, \"left\"];\n    }\n  } else if (y2 > y1 && x1 === x2) {\n    if (n1.direction === \"up\") {\n      return [2, [\"r\", \"f\"], \"right\"];\n    } else if (n1.direction === \"right\") {\n      return [1, [\"f\"], \"right\"];\n    } else if (n1.direction === \"left\") {\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\n    } else if (n1.direction === \"down\") {\n      return [2, [\"l\", \"f\"], \"right\"];\n    } else if (n1.direction === \"up-right\") {\n      return [1.5, null, \"right\"];\n    } else if (n1.direction === \"down-right\") {\n      return [1.5, null, \"right\"];\n    } else if (n1.direction === \"up-left\") {\n      return [2.5, null, \"right\"];\n    } else if (n1.direction === \"down-left\") {\n      return [2.5, null, \"right\"];\n    }\n  }\n}\n\nfunction manhattanDistance(n1, n2) {\n  let x = Math.abs(n2.row - n1.row);\n  let y = Math.abs(n2.col - n2.col);\n  return x + y;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/astar.js"],"names":["astar","grid","start","end","visitedNodesInOrder","distance","totalDistance","direction","unvisitedNodes","getNodes","length","sort","a","b","currentNode","shift","Infinity","push","isVisited","updateNeighbors","nodes","row","node","isWall","closestNode","currentClosest","index","i","heuristicDistance","splice","getNeighbours","neighbours","col","filter","neighbour","updateNode","getDistance","manhattanDistance","distanceToCompare","previousNode","path","n1","n2","x1","x2","y1","y2","x","Math","abs","y"],"mappings":"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","sourcesContent":["/*export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n\tconsole.log(openSet);\r\n\tconsole.log(fscore);\r\n\tconsole.log(gScore);\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n} \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}*/\r\n\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !end || start === end) {\r\n\t\treturn false;\r\n\t}\r\n\tlet visitedNodesInOrder = [];\r\n\tstart.distance = 0;\r\n\tstart.totalDistance = 0;\r\n\tstart.direction = \"up\";\r\n\tlet unvisitedNodes=getNodes(grid);\r\n\twhile (unvisitedNodes.length) {\r\n\t\tunvisitedNodes.sort((a,b) => a.distance - b.distance);\r\n\t\tlet currentNode = unvisitedNodes.shift();\r\n\t\tif (currentNode.distance === Infinity) \r\n\t\t  \treturn false;\r\n\t\tvisitedNodesInOrder.push(currentNode);\r\n\t  \tcurrentNode.isVisited=true;;\r\n\t  \tif (currentNode === end) {\r\n\t\t\treturn visitedNodesInOrder;\r\n\t  \t}\r\n\t  \tupdateNeighbors(grid, currentNode, end, start);\r\n\t}\r\n}\r\nfunction getNodes(grid){\r\n\tlet nodes = [];\r\n\t\tfor(const row of grid){\r\n\t\t\tfor(const node of row){\r\n\t\t\t\tif(!node.isWall){\r\n\t\t\t\t\tnodes.push(node);\r\n\t\t\t\t}\r\n\t\t \t}\r\n\t \t}\r\n\treturn nodes;\r\n}\r\n\r\nfunction closestNode(nodes, unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t  if (!currentClosest || currentClosest.totalDistance > nodes[unvisitedNodes[i]].totalDistance) {\r\n\t\tcurrentClosest = nodes[unvisitedNodes[i]];\r\n\t\tindex = i;\r\n\t  } else if (currentClosest.totalDistance === nodes[unvisitedNodes[i]].totalDistance) {\r\n\t\tif (currentClosest.heuristicDistance > nodes[unvisitedNodes[i]].heuristicDistance) {\r\n\t\t  currentClosest = nodes[unvisitedNodes[i]];\r\n\t\t  index = i;\r\n\t\t}\r\n\t  }\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n}\r\n\r\nfunction getNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0){\r\n        neighbours.push(grid[row - 1][col]);\r\n    } \r\n    if (row < grid.length - 1){\r\n        neighbours.push(grid[row + 1][col]);\r\n    }\r\n    if (col > 0){\r\n        neighbours.push(grid[row][col - 1]);\r\n    }\r\n    if (col < grid[0].length - 1){\r\n        neighbours.push(grid[row][col + 1]);\r\n    }\r\n    return neighbours.filter(neighbour => !neighbour.isWall);\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, start, end) {\r\n\tlet neighbours = getNeighbours(currentNode,grid);\r\n\tfor (let neighbour of neighbours) {\r\n\t\tif (end) {\r\n\t\t\tupdateNode(currentNode, neighbour, end, start );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tupdateNode(currentNode, neighbour);\r\n\t  \t}\r\n\t}\r\n}\r\n\r\n  \r\nfunction updateNode(currentNode, neighbour, end) {\r\n\tlet distance = getDistance(currentNode, neighbour);\r\n\tif (!neighbour.heuristicDistance) \r\n\t\tneighbour.heuristicDistance = manhattanDistance(neighbour, end);\r\n\tlet distanceToCompare = currentNode.distance + distance[0];\r\n\tif (distanceToCompare < neighbour.distance) {\r\n\t\tneighbour.distance = distanceToCompare;\r\n\t\tneighbour.totalDistance = neighbour.distance + neighbour.heuristicDistance;\r\n\t\tneighbour.previousNode = currentNode;\r\n\t\tneighbour.path = distance[1];\r\n\t\tneighbour.direction = distance[2];\r\n\t}\r\n}\r\n\r\n   \r\nfunction getDistance(n1, n2) {\r\n\tlet x1=n1.row;\r\n\tlet x2=n2.row;\r\n\tlet y1=n1.col;\r\n\tlet y2=n2.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (n1.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (n1.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (n1.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n\r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\n  \r\n  \r\n  \r\n  "]},"metadata":{},"sourceType":"module"}