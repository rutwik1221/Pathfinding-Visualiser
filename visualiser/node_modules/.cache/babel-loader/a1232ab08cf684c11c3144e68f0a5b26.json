{"ast":null,"code":"/*export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n\tconsole.log(openSet);\r\n\tconsole.log(fscore);\r\n\tconsole.log(gScore);\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n} \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}*/\nexport function astar(grid, start, end) {\n  if (!start || !target || start === target) {\n    return false;\n  }\n\n  nodes[start].distance = 0;\n  nodes[start].totalDistance = 0;\n  nodes[start].direction = \"up\";\n  let unvisitedNodes = Object.keys(nodes);\n\n  while (unvisitedNodes.length) {\n    let currentNode = closestNode(nodes, unvisitedNodes);\n\n    while (currentNode.status === \"wall\" && unvisitedNodes.length) {\n      currentNode = closestNode(nodes, unvisitedNodes);\n    }\n\n    if (currentNode.distance === Infinity) return false;\n    nodesToAnimate.push(currentNode);\n    currentNode.status = \"visited\";\n\n    if (currentNode.id === target) {\n      return \"success!\";\n    }\n\n    updateNeighbors(nodes, currentNode, boardArray, target, name, start, heuristic);\n  }\n}\n\nfunction closestNode(nodes, unvisitedNodes) {\n  let currentClosest, index;\n\n  for (let i = 0; i < unvisitedNodes.length; i++) {\n    if (!currentClosest || currentClosest.totalDistance > nodes[unvisitedNodes[i]].totalDistance) {\n      currentClosest = nodes[unvisitedNodes[i]];\n      index = i;\n    } else if (currentClosest.totalDistance === nodes[unvisitedNodes[i]].totalDistance) {\n      if (currentClosest.heuristicDistance > nodes[unvisitedNodes[i]].heuristicDistance) {\n        currentClosest = nodes[unvisitedNodes[i]];\n        index = i;\n      }\n    }\n  }\n\n  unvisitedNodes.splice(index, 1);\n  return currentClosest;\n}\n\nfunction updateNeighbors(nodes, node, boardArray, target, name, start, heuristic) {\n  let neighbors = getNeighbors(node.id, nodes, boardArray);\n\n  for (let neighbor of neighbors) {\n    if (target) {\n      updateNode(node, nodes[neighbor], nodes[target], name, nodes, nodes[start], heuristic, boardArray);\n    } else {\n      updateNode(node, nodes[neighbor]);\n    }\n  }\n}\n\nfunction updateNode(currentNode, targetNode, actualTargetNode, name, nodes, actualStartNode, heuristic, boardArray) {\n  let distance = getDistance(currentNode, targetNode);\n  if (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\n  let distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n\n  if (distanceToCompare < targetNode.distance) {\n    targetNode.distance = distanceToCompare;\n    targetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\n    targetNode.previousNode = currentNode.id;\n    targetNode.path = distance[1];\n    targetNode.direction = distance[2];\n  }\n}\n\nfunction getNeighbors(id, nodes, boardArray) {\n  let coordinates = id.split(\"-\");\n  let x = parseInt(coordinates[0]);\n  let y = parseInt(coordinates[1]);\n  let neighbors = [];\n  let potentialNeighbor;\n\n  if (boardArray[x - 1] && boardArray[x - 1][y]) {\n    potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`;\n    if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x + 1] && boardArray[x + 1][y]) {\n    potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`;\n    if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x][y - 1]) {\n    potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`;\n    if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  if (boardArray[x][y + 1]) {\n    potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`;\n    if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\n  }\n\n  return neighbors;\n}\n\nfunction getDistance(nodeOne, nodeTwo) {\n  let currentCoordinates = nodeOne.id.split(\"-\");\n  let targetCoordinates = nodeTwo.id.split(\"-\");\n  let x1 = parseInt(currentCoordinates[0]);\n  let y1 = parseInt(currentCoordinates[1]);\n  let x2 = parseInt(targetCoordinates[0]);\n  let y2 = parseInt(targetCoordinates[1]);\n\n  if (x2 < x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [1, [\"f\"], \"up\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"l\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"up\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"up\"];\n    }\n  } else if (x2 > x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"l\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [1, [\"f\"], \"down\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"down\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"down\"];\n    }\n  }\n\n  if (y2 < y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [1, [\"f\"], \"left\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"r\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"left\"];\n    }\n  } else if (y2 > y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [1, [\"f\"], \"right\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"l\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"right\"];\n    }\n  }\n}\n\nfunction manhattanDistance(nodeOne, nodeTwo) {\n  let nodeOneCoordinates = nodeOne.id.split(\"-\").map(ele => parseInt(ele));\n  let nodeTwoCoordinates = nodeTwo.id.split(\"-\").map(ele => parseInt(ele));\n  let xOne = nodeOneCoordinates[0];\n  let xTwo = nodeTwoCoordinates[0];\n  let yOne = nodeOneCoordinates[1];\n  let yTwo = nodeTwoCoordinates[1];\n  let xChange = Math.abs(xOne - xTwo);\n  let yChange = Math.abs(yOne - yTwo);\n  return xChange + yChange;\n}","map":{"version":3,"sources":["D:/rutwik/Documents/New folder/Web Apps/visualiser/src/algorithms/astar.js"],"names":["astar","grid","start","end","target","nodes","distance","totalDistance","direction","unvisitedNodes","Object","keys","length","currentNode","closestNode","status","Infinity","nodesToAnimate","push","id","updateNeighbors","boardArray","name","heuristic","currentClosest","index","i","heuristicDistance","splice","node","neighbors","getNeighbors","neighbor","updateNode","targetNode","actualTargetNode","actualStartNode","getDistance","manhattanDistance","distanceToCompare","weight","previousNode","path","coordinates","split","x","parseInt","y","potentialNeighbor","toString","nodeOne","nodeTwo","currentCoordinates","targetCoordinates","x1","y1","x2","y2","nodeOneCoordinates","map","ele","nodeTwoCoordinates","xOne","xTwo","yOne","yTwo","xChange","Math","abs","yChange"],"mappings":"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","sourcesContent":["/*export function astar(grid, start, end) {\r\n    if (start === end) {\r\n    \treturn false;\r\n    }\r\n\tlet openSet= new Set();\r\n\topenSet.add(start);\r\n    let cameFrom = new Map();\r\n\tlet gScore = new Map();\r\n\tgScore.set(start,0);\r\n\tlet fscore = new Map();\r\n\tfscore.set(start,manhattanDistance(start,end))\r\n\tconsole.log(openSet);\r\n\tconsole.log(fscore);\r\n\tconsole.log(gScore);\r\n    while(openSet.size>0){\r\n    \tlet current = min(fscore);\r\n    \tif(current===end){\r\n        \treturn shortestPath(end);\r\n    \t}\r\n    \topenSet.delete(current);\r\n\t\tlet neighbours = getNeighbours(grid,current);\r\n\t\tfor(let node of neighbours){\r\n\t\t\tlet tentative_gScore = gScore.get(current) + 1;\r\n\t\t\tif(tentative_gScore<gScore.get(node)){\r\n\t\t\t\tcameFrom.set(node,current);\r\n\t\t\t\tgScore.set(node,tentative_gScore);\r\n\t\t\t\tfscore.set(node,gScore.get(node)+manhattanDistance(node,end));\r\n\t\t\t\tif(!openSet.has(node)){\r\n\t\t\t\t\topenSet.add(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n}\r\nfunction min(fscore){\r\n\tlet minKey, minVal=99999;\r\n\tfor(let [key,value] of fscore){\r\n    \tif(value<minVal){\r\n        \tminVal=value;\r\n        \tminKey=key\r\n    \t}\r\n\t}\r\n    return minKey;\r\n}\r\nfunction getNeighbours(grid,current){\r\n\tlet neighbours=[];  \r\n\tif(current.row===0){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.row===19){\r\n\t\tif(current.col===0){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t}\r\n\t\telse if(current.col===49){\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t\t}\r\n\t}\r\n\telse if(current.col===0){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t}\r\n\telse if(current.col===49){\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\telse{\r\n\t\tneighbours.push(grid[current.row+1][current.col]);\r\n\t\tneighbours.push(grid[current.row-1][current.col]);\r\n\t\tneighbours.push(grid[current.row][current.col+1]);\r\n\t\tneighbours.push(grid[current.row][current.col-1]);\r\n\t}\r\n\treturn neighbours.filter(n => !n.isWall);\r\n} \r\nfunction manhattanDistance(n1, n2) {\r\n\tlet x=Math.abs(n2.row-n1.row);\r\n\tlet y=Math.abs(n2.col-n2.col);\r\n\treturn (x+y);\r\n}\r\nfunction shortestPath(node){\r\n    const path = [];\r\n    while(node!==null){\r\n        path.puah(node);\r\n        node = node.previousNode;\r\n    }\r\n    return path;\r\n}*/\r\n\r\nexport function astar(grid, start, end) {\r\n\tif (!start || !target || start === target) {\r\n\t  return false;\r\n\t}\r\n\tnodes[start].distance = 0;\r\n\tnodes[start].totalDistance = 0;\r\n\tnodes[start].direction = \"up\";\r\n\tlet unvisitedNodes = Object.keys(nodes);\r\n\twhile (unvisitedNodes.length) {\r\n\t  let currentNode = closestNode(nodes, unvisitedNodes);\r\n\t  while (currentNode.status === \"wall\" && unvisitedNodes.length) {\r\n\t\tcurrentNode = closestNode(nodes, unvisitedNodes)\r\n\t  }\r\n\t  if (currentNode.distance === Infinity) return false;\r\n\t  nodesToAnimate.push(currentNode);\r\n\t  currentNode.status = \"visited\";\r\n\t  if (currentNode.id === target) {\r\n\t\treturn \"success!\";\r\n\t  }\r\n\t  updateNeighbors(nodes, currentNode, boardArray, target, name, start, heuristic);\r\n\t}\r\n  }\r\n  \r\n  function closestNode(nodes, unvisitedNodes) {\r\n\tlet currentClosest, index;\r\n\tfor (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t  if (!currentClosest || currentClosest.totalDistance > nodes[unvisitedNodes[i]].totalDistance) {\r\n\t\tcurrentClosest = nodes[unvisitedNodes[i]];\r\n\t\tindex = i;\r\n\t  } else if (currentClosest.totalDistance === nodes[unvisitedNodes[i]].totalDistance) {\r\n\t\tif (currentClosest.heuristicDistance > nodes[unvisitedNodes[i]].heuristicDistance) {\r\n\t\t  currentClosest = nodes[unvisitedNodes[i]];\r\n\t\t  index = i;\r\n\t\t}\r\n\t  }\r\n\t}\r\n\tunvisitedNodes.splice(index, 1);\r\n\treturn currentClosest;\r\n  }\r\n  \r\n  function updateNeighbors(nodes, node, boardArray, target, name, start, heuristic) {\r\n\tlet neighbors = getNeighbors(node.id, nodes, boardArray);\r\n\tfor (let neighbor of neighbors) {\r\n\t  if (target) {\r\n\t\tupdateNode(node, nodes[neighbor], nodes[target], name, nodes, nodes[start], heuristic, boardArray);\r\n\t  } else {\r\n\t\tupdateNode(node, nodes[neighbor]);\r\n\t  }\r\n\t}\r\n  }\r\n  \r\n  function updateNode(currentNode, targetNode, actualTargetNode, name, nodes, actualStartNode, heuristic, boardArray) {\r\n\tlet distance = getDistance(currentNode, targetNode);\r\n\tif (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\r\n\tlet distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\r\n\tif (distanceToCompare < targetNode.distance) {\r\n\t  targetNode.distance = distanceToCompare;\r\n\t  targetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\r\n\t  targetNode.previousNode = currentNode.id;\r\n\t  targetNode.path = distance[1];\r\n\t  targetNode.direction = distance[2];\r\n\t}\r\n  }\r\n  \r\n  function getNeighbors(id, nodes, boardArray) {\r\n\tlet coordinates = id.split(\"-\");\r\n\tlet x = parseInt(coordinates[0]);\r\n\tlet y = parseInt(coordinates[1]);\r\n\tlet neighbors = [];\r\n\tlet potentialNeighbor;\r\n\tif (boardArray[x - 1] && boardArray[x - 1][y]) {\r\n\t  potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`\r\n\t  if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n\t}\r\n\tif (boardArray[x + 1] && boardArray[x + 1][y]) {\r\n\t  potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`\r\n\t  if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n\t}\r\n\tif (boardArray[x][y - 1]) {\r\n\t  potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`\r\n\t  if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n\t}\r\n\tif (boardArray[x][y + 1]) {\r\n\t  potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`\r\n\t  if (nodes[potentialNeighbor].status !== \"wall\") neighbors.push(potentialNeighbor);\r\n\t}\r\n\treturn neighbors;\r\n  }\r\n  \r\n  \r\n  function getDistance(nodeOne, nodeTwo) {\r\n\tlet currentCoordinates = nodeOne.id.split(\"-\");\r\n\tlet targetCoordinates = nodeTwo.id.split(\"-\");\r\n\tlet x1 = parseInt(currentCoordinates[0]);\r\n\tlet y1 = parseInt(currentCoordinates[1]);\r\n\tlet x2 = parseInt(targetCoordinates[0]);\r\n\tlet y2 = parseInt(targetCoordinates[1]);\r\n\tif (x2 < x1 && y1 === y2) {\r\n\t  if (nodeOne.direction === \"up\") {\r\n\t\treturn [1, [\"f\"], \"up\"];\r\n\t  } else if (nodeOne.direction === \"right\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"up\"];\r\n\t  } else if (nodeOne.direction === \"left\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"up\"];\r\n\t  } else if (nodeOne.direction === \"down\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n\t  } else if (nodeOne.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (nodeOne.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  } else if (nodeOne.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"up\"];\r\n\t  } else if (nodeOne.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"up\"];\r\n\t  }\r\n\t} else if (x2 > x1 && y1 === y2) {\r\n\t  if (nodeOne.direction === \"up\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n\t  } else if (nodeOne.direction === \"right\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"down\"];\r\n\t  } else if (nodeOne.direction === \"left\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"down\"];\r\n\t  } else if (nodeOne.direction === \"down\") {\r\n\t\treturn [1, [\"f\"], \"down\"];\r\n\t  } else if (nodeOne.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (nodeOne.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  } else if (nodeOne.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"down\"];\r\n\t  } else if (nodeOne.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"down\"];\r\n\t  }\r\n\t}\r\n\tif (y2 < y1 && x1 === x2) {\r\n\t  if (nodeOne.direction === \"up\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"left\"];\r\n\t  } else if (nodeOne.direction === \"right\") {\r\n\t\treturn [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n\t  } else if (nodeOne.direction === \"left\") {\r\n\t\treturn [1, [\"f\"], \"left\"];\r\n\t  } else if (nodeOne.direction === \"down\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"left\"];\r\n\t  } else if (nodeOne.direction === \"up-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (nodeOne.direction === \"down-right\") {\r\n\t\treturn [2.5, null, \"left\"];\r\n\t  } else if (nodeOne.direction === \"up-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  } else if (nodeOne.direction === \"down-left\") {\r\n\t\treturn [1.5, null, \"left\"];\r\n\t  }\r\n\t} else if (y2 > y1 && x1 === x2) {\r\n\t  if (nodeOne.direction === \"up\") {\r\n\t\treturn [2, [\"r\", \"f\"], \"right\"];\r\n\t  } else if (nodeOne.direction === \"right\") {\r\n\t\treturn [1, [\"f\"], \"right\"];\r\n\t  } else if (nodeOne.direction === \"left\") {\r\n\t\treturn [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n\t  } else if (nodeOne.direction === \"down\") {\r\n\t\treturn [2, [\"l\", \"f\"], \"right\"];\r\n\t  } else if (nodeOne.direction === \"up-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (nodeOne.direction === \"down-right\") {\r\n\t\treturn [1.5, null, \"right\"];\r\n\t  } else if (nodeOne.direction === \"up-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  } else if (nodeOne.direction === \"down-left\") {\r\n\t\treturn [2.5, null, \"right\"];\r\n\t  }\r\n\t}\r\n  }\r\n  \r\n  function manhattanDistance(nodeOne, nodeTwo) {\r\n\tlet nodeOneCoordinates = nodeOne.id.split(\"-\").map(ele => parseInt(ele));\r\n\tlet nodeTwoCoordinates = nodeTwo.id.split(\"-\").map(ele => parseInt(ele));\r\n\tlet xOne = nodeOneCoordinates[0];\r\n\tlet xTwo = nodeTwoCoordinates[0];\r\n\tlet yOne = nodeOneCoordinates[1];\r\n\tlet yTwo = nodeTwoCoordinates[1];\r\n  \r\n\tlet xChange = Math.abs(xOne - xTwo);\r\n\tlet yChange = Math.abs(yOne - yTwo);\r\n  \r\n\treturn (xChange + yChange);\r\n  }\r\n  \r\n  \r\n  \r\n  "]},"metadata":{},"sourceType":"module"}